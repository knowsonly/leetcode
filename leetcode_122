class Solution {
public:
    int maxProfit(vector<int>& prices) {
    int n=prices.size();
    int dp[n][2];
    dp[0][0]=0;
    dp[0][1]=-prices[0];
    for(int i=1;i<n;i++){
        //for(int j=0;j<2;j++){
            //if (j==0){
                dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
            //}else{
                dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);
                //}
        }
    return dp[n-1][0];}
};

/*这个问题可以使用动态规划的方法来解决。动态规划是一种算法设计技术，常用于解决具有重叠子问题和最优子结构的问题。在这个股票交易问题中，我们可以通过以下步骤来设计算法：

1. 定义状态
首先，定义动态规划的状态。在这个问题中，状态可以表示为 dp[i][j]，其中 i 表示第 i 天，j 有两个可能的值：

0：表示在第 i 天结束时手上没有持有股票。
1：表示在第 i 天结束时手上持有一股股票。
2. 状态转移方程
接下来，确定如何从之前的状态转移到当前状态。状态转移方程可以表示为：

如果今天不持有股票（dp[i][0]），那么可能是昨天就没有股票，或者是昨天有股票但今天卖出了。所以 dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])。
如果今天持有股票（dp[i][1]），那么可能是昨天就持有股票，或者是今天买入的。所以 dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])。
3. 初始化
对于初始状态，dp[0][0] 应该为 0（第一天结束时没有股票），dp[0][1] 应该为 -prices[0]（第一天就买入股票）。

4. 计算最终结果
遍历数组 prices，按照状态转移方程更新状态。最终的答案是在最后一天结束时，手上没有股票的最大利润，即 dp[n-1][0]，其中 n 是数组 prices 的长度。*/
